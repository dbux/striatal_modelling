function[connections, list] = gen_phys_connlist(striatum, connections, attr, phys, conn, flags)
    % Assign MSNs as D1 or D2 and to a particular channel

    % Append directory for connection lists
%     listpath = fullfile(striatum.dirname, 'connection_lists');
    listpath = fullfile(attr.save_path, 'connection_lists');
    mkdir(listpath);

    % Start list timer
    timer.list = tic;

    % Create a list of all MSN, FSI, and D1 / D2 neuron IDs (without connections)
    % Column 1 is the unique neuron ID in the striatum generated by MatLab
    % Column 2 is the neuron's ID within that group required by SpineCreator
    list.msn = unique(connections.msnmsn(:,1));
    list.d1  = [list.msn(1 : ceil(length(list.msn) / 2))' ; 0 : ceil(length(list.msn) / 2) - 1]';
    list.d2  = [list.msn(length(list.d1) + 1 : end)' ; 0 : floor(length(list.msn) / 2) - 1]';
    list.fsi = sort(unique([unique(connections.fsifsi(:,1)) ; unique(connections.fsimsn(:,1))]));
    list.fsi(:,2) = 0:length(list.fsi) - 1;

    % Separate all MSN_MSN connections into D_type lists
    timer.chans = tic;
    if flags.progress
        fprintf('\nSeparating connections into channels… ');
    end
    connections.d1.all = connections.msnmsn((connections.msnmsn(:, 1) <= max(list.d1(:, 1))), :);
    connections.d1.d1  = connections.d1.all((connections.d1.all(:, 2) <= max(list.d1(:, 1))), :);
    connections.d1.d2  = connections.d1.all((connections.d1.all(:, 2) > max(list.d1(:, 1))), :);

    connections.d2.all = connections.msnmsn((connections.msnmsn(:, 1) > max(list.d1(:, 1))), :);
    connections.d2.d1  = connections.d2.all((connections.d2.all(:, 2) <= max(list.d1(:, 1))), :);
    connections.d2.d2  = connections.d2.all((connections.d2.all(:, 2) > max(list.d1(:, 1))), :);

    connections.fsi.d1 = connections.fsimsn((connections.fsimsn(:, 2) <= max(list.d1(:, 1))), :);
    connections.fsi.d2 = connections.fsimsn((connections.fsimsn(:, 2) > max(list.d1(:, 1))), :);
    if flags.progress
        fprintf('done! (%3.2fs)\n', toc(timer.chans))
        fprintf('(%d%% MSNs and %d%% FSIs background-only; %s%% channel width)\n', ...
            conn.bkg_msn, conn.bkg_fsi, num2str(phys.ch_width))
    end

    % It's useful to know how many of each neuron type there are
    num.d1  = size(list.d1, 1);
    num.d2  = size(list.d2, 1);
    num.msn = size(list.msn, 1);
    num.fsi = size(list.fsi, 1);
    num.gap = size(connections.gap, 1);

    % (Approximate) number of MSNs of each type to leave as background only
    num.bkg_msn = round(num.msn * (conn.bkg_msn / 100) / 2);

    % (Approximate) number of FSIs to leave as background only
    num.bkg_fsi = round(num.fsi * (conn.bkg_fsi / 100));

    % Number of MSNs of each type and FSIs to put in each channel
    % num.msn_ch = floor((num.msn / 2 - num.bkg) / conn.ch_all);
    num.d1_ch  = (num.d1 - num.bkg_msn) / conn.ch_all;
    num.d2_ch  = (num.d2 - num.bkg_msn) / conn.ch_all;
    num.fsi_ch = num.fsi - num.bkg_fsi;

    %% CORTICO-STRIATAL channel connections - Uses SpineCreator neuron IDs
    if flags.progress
        fprintf('\nCreating connection lists:\n');
        fprintf('1) Cortical channel connections… ')
    end
    timer.conn1 = tic;
    
    % Generate connection ID prefix
    conn_prefix = matlab.lang.makeValidName(strcat('bkMSN', num2str(conn.bkg_msn), '_bkFSI', num2str(conn.bkg_fsi)));

    % Cortico-striatal connections differ based on number of input channels
    if conn.ch_all == 1
        % Create connection ID for current background / channel width profile
        conn_id = matlab.lang.makeValidName(strcat(conn_prefix, '_1CH'));
    
        % In the single-channel model it doesn't matter which neurons don't
        % receive connections since neuron ID is not associated with location

        connections.cortex.ch1.d1.(conn_id)  = [ 0 : num.d1_ch  - 1                          ; 0 : num.d1_ch - 1]';
        connections.cortex.ch1.d2.(conn_id)  = [(0 : num.d2_ch  - 1) + num.d1_ch             ; 0 : num.d2_ch - 1]';
        connections.cortex.ch1.fsi.(conn_id) = [(0 : num.fsi_ch - 1) + num.d1_ch + num.d2_ch ; 0 : num.fsi_ch - 1]';

        % Save connection lists
        if flags.save
            name.src = sprintf('CH1_input');
            % For both D1 and D2 MSNs
            for j = 1:2           
                d_dst = sprintf('d%d', j);               
                name.dst = sprintf('Striatum_D%d', j);

                % Create both AMPA and NMDA connections to MSNs
                for k = 0:1          
                    % Channel input

%                     name.syn = [sprintf('syn%d_', k), conn_id];
                    name.syn = sprintf('syn%d', k);
                    save_list(fullfile(listpath, conn_id), connections.cortex.ch1.(d_dst).(conn_id), name, flags);
                end
            end

            % FSI populations only use a single synapse
            name.dst = 'Striatum_FSI';
%             name.syn = ['syn0_', conn_id];
            name.syn = 'syn0';
            save_list(fullfile(listpath, conn_id), connections.cortex.ch1.fsi.(conn_id), name, flags);
        end

    elseif conn.ch_all == 2
        % Create connection ID for current background / channel width profile
        % Must convert phys.ch_width to string to avoid floating-point errors
        % Must do string substitution becuase struct fields cannot contain '.'
%         conn_id = sprintf('bkMSN%d_bkFSI%d_wCH%d_2CH', conn.bkg_msn, conn.bkg_fsi, matlab.lang.makeValidName(phys.ch_width));
        conn_id = matlab.lang.makeValidName(strcat(conn_prefix, '_wCH', num2str(phys.ch_width), '_2CH'));
    
        % Physically partition a two-channel striatum
        if flags.phys_ch  
            for i = 1:2
                % Set dynamic structure fieldname
                msn = sprintf('d%d', i);

                % MSNs assigned to channel 1 or 2 based on physical location on
                % striatal X-axis, modified based on width value. Width <0.5
                % creates a background-only gap between channels, width
                % >0.5 creates a region with MSNs in both channels   
%                 list.ch1.(msn) = list.(msn)(striatum.neurons(list.(msn)(:,1), 1) <= (phys.size / 2) + (phys.size * (phys.ch_width / 100) / 2), :);
%                 list.ch2.(msn) = list.(msn)(striatum.neurons(list.(msn)(:,1), 1) >= (phys.size / 2) - (phys.size * (phys.ch_width / 100) / 2), :); 
                list.ch1.(msn) = list.(msn)(striatum.neurons(list.(msn)(:,1), 1) <= 0 + (phys.size * (phys.ch_width / 100)), :);
                list.ch2.(msn) = list.(msn)(striatum.neurons(list.(msn)(:,1), 1) >= phys.size - (phys.size * (phys.ch_width / 100)), :);

                for j = 1:conn.ch_all
                    % Set dynamic structure fieldname
                    ch = sprintf('ch%d', j);

                    % Trim MSN and FSI lists according to requested background-only percentage
                    list.(ch).(msn) = list.(ch).(msn)(1:end - (floor(size(list.(ch).(msn), 1) * (conn.bkg_msn / 100))), :);
                    list.(ch).fsi   = list.fsi(1:end - (floor(size(list.fsi, 1) * (conn.bkg_fsi / 100))), :);

                    % Channel connections to striatum
                    % FROM:  Each cortical channel (-1 for SpineCreator 0-indexing)
                    % TO:    Each MSN or FSI in each channel
                    % DELAY: N/A                  
                    if i==2
                        % D2 connections come after D1 connections
                        connections.cortex.(ch).(msn).(conn_id) = ...
                            [(0 : length(list.(ch).(msn)) - 1) + length(list.(ch).d1) ; list.(ch).(msn)(:,2)']';
                        
                        % FSI connections come after all MSN connections
                        connections.cortex.(ch).fsi.(conn_id) = ...
                            [(0 : length(list.(ch).fsi) - 1) + length(list.(ch).d1) + length(list.(ch).d2) ; list.(ch).fsi(:,2)']';
                    else
                        % No special considerations for D1 connections
                        connections.cortex.(ch).(msn).(conn_id) = ...
                            [0 : length(list.(ch).(msn)) - 1 ; list.(ch).(msn)(:,2)']';
                    end                      
                end
            end

    %     % Normal procedure for non-partitioned multi-channel striatum    
        else  
            fprintf('\nNew connections for non-partioned striatum not yet done!')
    %         % Position of the first and last neuron in the channel
    %         ch_first = 1;
    %         ch_last = num.msn_ch;
    % 
    %         for i = 1:conn.ch_all
    %             % Set dynamic structure fieldname
    %             ch = sprintf('ch%d', i);
    % 
    %             % The neurons structure contains a list of members of each channel
    %             list.(ch).d1 = list.d1(ch_first : ch_last, :);
    %             list.(ch).d2 = list.d2(ch_first : ch_last, :);
    % 
    %             % Create channel connections to striatum
    %             % FROM: Each cortical channel (-1 for SpineCreator 0-indexing)
    %             % TO:   Each MSN or FSI in each channel
    %             % DELAY:N/A
    %             connections.cortex.(ch).d1 = [0 : num.msn_ch - 1 ; list.(ch).d1(:,2)']';
    %             connections.cortex.(ch).d2 = [0 : num.msn_ch - 1 ; list.(ch).d2(:,2)']';
    %             connections.cortex.(ch).fsi= [0 : num.fsi - 1    ; list.fsi(:,2)'    ]'; 
    % 
    %             % Create channel connections to basal ganglia
    %             % FROM: Each cortical channel (-1 for SpineCreator 0-indexing)
    %             % TO:   Single BG neuron in each channel
    %             % DELAY:N/A
    %             if num.msn_ch > attr.max_bg
    %                 connections.cortex.(ch).bg = [0 : attr.max_bg - 1 ; zeros(1, attr.max_bg) + (i - 1)]'; 
    %             else
    %                 connections.cortex.(ch).bg = [0 : num.msn_ch - 1 ; zeros(1, num.msn_ch) + (i - 1)]';  
    %             end
    % 
    %             % Increment channel start/end markers for the next channel
    %             ch_first = ch_last + 1;
    %             ch_last = ch_last + num.msn_ch;
    %         end
        end

        % Save connection lists
        if flags.save
            for i = 1:conn.ch_all
                % Set dynamic structure fieldname
                ch = sprintf('ch%d', i);       
                name.src = sprintf('CH%d_input', i);

                % For both D1 and D2 MSNs
                for j = 1:2           
                    d_dst = sprintf('d%d', j);
                    name.dst = sprintf('Striatum_D%d', j);

                    % Create both AMPA and NMDA connections to MSNs
                    for k = 0:1 
                        name.syn = sprintf('syn%d', k); 
                        save_list(fullfile(listpath, conn_id), connections.cortex.(ch).(d_dst).(conn_id), name, flags);
                    end
                end

                % FSIs only use a single synapse
                name.dst = 'Striatum_FSI';
                name.syn = 'syn0';
                save_list(fullfile(listpath, conn_id), connections.cortex.(ch).fsi.(conn_id), name, flags);
            end
        end

    elseif conn.ch_all > 2
        fprintf('3+ channel connectivity not yet done')
    end


    if flags.progress
        fprintf('done! (%1.2fs)\n', toc(timer.conn1))
    end


    %% STRIATAL GABA connections - Converts MatLab to SpineCreator neuron IDs
    if flags.progress
        fprintf('2) Striatal GABA connections… ')
    end
    timer.conn3 = tic;

    % From both D1 and D2 MSNs
    for i = 1:2
        d_src = sprintf('d%d', i); 
        name.src = sprintf('Striatum_D%d', i);

        % GABA projections always use syn0
        name.syn = 'syn0';

        % To both D1 and D2 MSNs
        for j = 1:2 
            d_dst = sprintf('d%d',j);
            name.dst = sprintf('Striatum_D%d', j);

            % If connections already exist, don't recreate
            if ~exist(fullfile(listpath, ['conn_', name.src, '_to_', name.dst, '_', name.syn, '.csv']), 'file')        
                % Convert MatLab neuron IDs to SpineCreator IDs
                [~, src] = ismember(connections.(d_src).(d_dst)(:,1), list.(d_src)(:,1));
                [~, dst] = ismember(connections.(d_src).(d_dst)(:,2), list.(d_dst)(:,1));

                % Create list of undirected MSN-MSN connections
                % FROM: D1 or D2 MSNs
                % TO:   D1 or D2 MSNs
                % DELAY:As defined in connections.(d_src).(d_dst)(:,3)
                connections.gaba.(d_src).(d_dst) = ...
                    [list.(d_src)(src,2)' ; list.(d_dst)(dst,2)' ; connections.(d_src).(d_dst)(:,3)']';

                % Save connection lists
                if flags.save
                    save_list(listpath, connections.gaba.(d_src).(d_dst), name, flags);
                end
            end
        end

        % From FSIs to MSNs
        f_dst = sprintf('d%d', i); 
        name.src = 'Striatum_FSI';
        name.dst = sprintf('Striatum_D%d', i);

        % If connections already exist, don't recreate
%         if ~exist(sprintf([listpath, 'conn_', name.src, '_to_', name.dst, '_', name.syn, '.csv']), 'file') 
        if ~exist(fullfile(listpath, ['conn_', name.src, '_to_', name.dst, '_', name.syn, '.csv']), 'file') 
            % Convert MatLab neuron IDs to SpineCreator IDs
            [~, src] = ismember(connections.fsi.(f_dst)(:,1), list.fsi(:,1));
            [~, dst] = ismember(connections.fsi.(f_dst)(:,2), list.(f_dst)(:,1));

            % Create list of undirected FSI-MSN connections
            % FROM: FSIs
            % TO:   D1 or D2 MSNs
            % DELAY:As defined in connections.fsi.(f_dst)(:,3)
            connections.gaba.fsi.(f_dst) = [list.fsi(src,2)' ; list.(f_dst)(dst,2)' ; connections.fsi.(f_dst)(:,3)']';

            % Save connection lists
            if flags.save
                save_list(listpath, connections.gaba.fsi.(f_dst), name, flags);
            end   
        end
    end

    % From FSIs to FSIs (GABA)
    name.src = 'Striatum_FSI';
    name.dst = 'Striatum_FSI';
    name.syn = 'syn0'; 

    % If connections already exist, don't recreate
%     if ~exist(sprintf([listpath, 'conn_', name.src, '_to_', name.dst, '_', name.syn, '.csv']), 'file') 
    if ~exist(fullfile(listpath, ['conn_', name.src, '_to_', name.dst, '_', name.syn, '.csv']), 'file') 
        % Convert MatLab neuron IDs to SpineCreator IDs
        [~, src] = ismember(connections.fsifsi(:,1), list.fsi(:,1));
        [~, dst] = ismember(connections.fsifsi(:,2), list.fsi(:,1));

        % Create list of undirected FSI-FSI GABA connections
        % FROM: FSIs
        % TO:   FSIs
        % DELAY:As defined in connections.fsifsi(:,3)
        connections.gaba.fsi.fsi = [list.fsi(src,2)' ; list.fsi(dst,2)' ; connections.fsifsi(:,3)']';

        % Save connection lists
        if flags.save
            save_list(listpath, connections.gaba.fsi.fsi, name, flags);
        end  

        % From FSIs to FSIs (Gap)
        % Convert MatLab neuron IDs to SpineCreator IDs
        try
            [~, src] = ismember(connections.gap(:,1), list.fsi(:,1));
            [~, dst] = ismember(connections.gap(:,2), list.fsi(:,1));
        catch
        end

        % Create list of FSI-FSI gap connections
        % Gap junctions have a nonstandard format
        % FROM: FSIs
        % TO:   FSIs
        % DELAY:N/A
        try
            connections.gap_sc.in1 =  [list.fsi(src,2)' ; 0 : num.gap - 1]';
            connections.gap_sc.in2 =  [list.fsi(dst,2)' ; 0 : num.gap - 1]';
            connections.gap_sc.out1 = [0 : num.gap - 1  ; list.fsi(src,2)']';
            connections.gap_sc.out2 = [0 : num.gap - 1  ; list.fsi(dst,2)']';        
        catch
            error('Could not create gap junctions!')
        end

        % Save connection lists
        if flags.save
            for i = 0:1
                g_in = sprintf('in%d', i + 1); 
                g_out = sprintf('out%d', i + 1); 

                name.syn = sprintf('syn%d', i);

                name.src = 'Striatum_FSI';               
                name.dst = 'FSI_GAP';
                save_list(listpath, connections.gap_sc.(g_in), name, flags);

                name.src = 'FSI_GAP';
                name.dst = 'Striatum_FSI';
                save_list(listpath, connections.gap_sc.(g_out), name, flags);        
            end
        end
    end

    if flags.progress
        fprintf('done! (%1.2fs)\n', toc(timer.conn3))
    end

    %% Save neuron list and connections to disk
    timer.save = tic;
    if flags.progress
        fprintf('\nSaving neuron and connection data… ')
    end
    
    if flags.save
        % Get physical co-ordinates of all MSNs and FSIs
        striatum.msn.d1  = striatum.neurons(list.d1(:, 1), :);
        striatum.msn.d2  = striatum.neurons(list.d2(:, 1), :);
        striatum.msn.all = [striatum.msn.d1 ; striatum.msn.d2];
        striatum.fsi.all = striatum.neurons(list.fsi(:, 1), :);

        striatum.fsi.active    = [];
        striatum.fsi.inactive  = [];
        striatum.msn.active.d1 = [];
        striatum.msn.active.d2 = [];

        for i = 1:conn.ch_all
            % Set dynamic structure fieldname
            ch = sprintf('ch%d', i);

            % Get active FSIs
            [~, idf] = ismember(connections.cortex.(ch).fsi.(conn_id)(:, 2), list.fsi(:, 2));
            striatum.fsi.active = unique([striatum.fsi.active ; striatum.fsi.all(idf, :)], 'rows');

            striatum.msn.(ch).all = [];

            % Get active MSNs
            for j = 1:2   
                % Set dynamic structure fieldname
                dx = sprintf('d%d', j);

                [~, idm] = ismember(connections.cortex.(ch).(dx).(conn_id)(:, 2), list.(dx)(:, 2));
                striatum.msn.(ch).(dx) = striatum.neurons(list.(dx)(idm, 1), :);
                striatum.msn.(ch).all  = [striatum.msn.(ch).all ; striatum.msn.(ch).(dx)];
                striatum.msn.active.(dx) = [striatum.msn.active.(dx) ; striatum.msn.(ch).(dx)];
            end
        end

        % Get inactive neurons
        striatum.msn.inactive.d1  = striatum.msn.d1(~ismember(striatum.msn.d1, striatum.msn.active.d1, 'rows'), :);
        striatum.msn.inactive.d2  = striatum.msn.d2(~ismember(striatum.msn.d2, striatum.msn.active.d2, 'rows'), :);
        striatum.msn.inactive.all = [striatum.msn.inactive.d1 ; striatum.msn.inactive.d2];
        striatum.fsi.inactive     = striatum.fsi.all(~ismember(striatum.fsi.all, striatum.fsi.active, 'rows'), :);

        % Export co-ordinates of all MSNs and FSIs
%         save_dir = [striatum.dirname, 'neuron_data/', strrep(conn_id, 'CH0_', 'CH0.')];
        save_dir = fullfile(attr.save_path, 'neuron_data', conn_id);
        if ~exist(save_dir, 'dir')
            mkdir(save_dir);
        end
        
        export_striatum(striatum.msn, 'striatum.msn', save_dir)
        export_striatum(striatum.fsi, 'striatum.fsi', save_dir)
        
        % Save list of neurons
        list_name = fullfile(save_dir, 'list.mat');   
        save(list_name, 'list');
    end
    
    function save_list(listpath, listfile, name, flags)
        % Given a pathname, a connection list and name, this will save the
        % connection list to a CSV and optionally convert it to binary format for
        % direct import to SpineCreator
        
        if ~exist(listpath, 'dir')
            mkdir(listpath)
        end

        % Save connection list to CSV
        filename = ['conn_', name.src, '_to_', name.dst, '_', name.syn];
        fid = fopen([fullfile(listpath, filename), '.csv'], 'w');

        % With or without connection delays as appropriate
        if size(listfile,2) == 3
            fprintf(fid, '%d, %d, %1.1f\r\n', transpose(listfile));
        elseif size(listfile,2) == 2
            fprintf(fid, '%d, %d\r\n', transpose(listfile));
        else
            error('Incorrect number of columns in connection %s', filename);
        end
        fclose(fid);

        % Export connection list as binary file if need
        if flags.binary
%             bin_convert(listfile, strcat(listpath, filename));
            
            filepath = fullfile(listpath, filename);
            
            intArray = int32([listfile(1:end,1)' ; listfile(1:end,2)']');
            if size(listfile, 2) == 3
                floatArray = single(listfile(1:end,3));
            end

            fileID = fopen([filepath, '.bin'], 'w');

            if exist('floatArray', 'var')
                for n = 1:size(listfile,1)
                    fwrite(fileID, intArray(n,:), 'int32');
                    fwrite(fileID, floatArray(n), 'single');
                end
            else
                for n = 1:size(listfile,1)
                    fwrite(fileID, intArray(n,:), 'int32');
                end
            end
            fclose(fileID);
        end
    end
    

    function export_striatum(s_data, s_name, s_dir)
        fields = fieldnames(s_data);
        for idx = 1:numel(fields)           
            % Get full name of current structure location
            curr_name = [s_name, '.', fields{idx}];

            % Get contents of next structure field
            s_field = s_data.(fields{idx});
            if isstruct(s_field)
                % Recurse function until nested structures end
                export_striatum(s_field, curr_name, s_dir);
            else
                % Export current co-ordinate matrix to disk
                cell2csv([fullfile(s_dir, curr_name), '.csv'], ...
                    [{[curr_name, '_X'], [curr_name, '_Y'], [curr_name, '_Z']} ; num2cell(s_field)]);
            end
        end   
    end
        
    if flags.progress
        fprintf('took %1.2f minutes. All done!\n', toc(timer.save)/60)
        fprintf('Profile connection lists generated in %1.2f minutes.\n', toc(timer.list) / 60)
    end
end